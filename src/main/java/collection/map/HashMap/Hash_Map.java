package collection.map.HashMap;

import generics.example.Student;

import java.util.HashMap;
import java.util.Map;

public class Hash_Map {
    /**
    1.1 HashMap:
    элементы: пара ключ-значение
                - не запоминает порядок добавления элементов
                   (все элементы будут перемешаны)
                +++ его методы работают очень быстро

     Правила:
     + значения и ключи могут быть null
     + ключи должны быть уникальными!!!
       (ключ первое значение при добавлении)
       если добавить два значения с одинаковыми ключами, то первый сотрется
     + ключи и значения могут быть любых типов данных, а также могут совпадать (по типу данных)
        напр., String-String
     + ключи должны быть не изменяемыми объектами (чтобы их хэшкод не менялся)
        для этого необходимо сделать в объекте ключа все поля final и класс тоже final
        - если мы изменим ключ, то никогда не найдем потом объект, так как хэшкод изменится

     HashMap.
     В его основе лежит массив. Элементами массива являются структуры LinkedList и заполняются
     элементами, которые мы добавляем в HashMap.

     !!!!!!
     Т.е HashMap состоит из 16 ячеек, в каждой из которых может быть LinkedList
     [0] [1] [2] [3] [4[]=>[]=>[]] [5] [6] [7[]=>[]] [8].....[14] [15[]=>[]=>[]=>[]=>[]]
     Этим и объясняется его быстродействие
     (мы точно знаем в какой из ячеек искать наш объект, а потом быстро пробегаемся по линкедЛисту)

     HashMap работает по принципам хэширования (преобразования с помощью метода hashcode объекта в число int)

     Этапы создания HashMap:
     1) Map<Integer,String> map1 = new HashMap<>();
     при написании этой строчки создается 16 ячеек [][][][][]...

     2)при добавлении элемента в HashMap
     проверяется не null ли ключ? если null, то в нулевую ячейку сразу ее кладут

     3)если нет, то вычисляется хэшкод для ключа (по формуле в классе HashMap метод Node, который имплементирует Entry)
     по хэшкоду вычисляется индекс ячейки и добавляется в нее
     если ключу соответствует несколько значений (хэшкод ключа одинаковый и equals=true), то происходит перезапись ячейки ячейку

     4)если вычисленный индекс ячейки равен уже заполненной ячейке, при этом их хэшкоды не равны, то значение
     добавляется в следующую за ней ячейку и создается связь с ячейкой(в которую хотели добавить, но она была занята)

     5)если индекс ячейки и нового объекта равны, если их хэшкоды тоже равны, а equals не равны, то ее тоже в конец
     записывают и создается связь с последней ячейкой

     Таким образом:

     Ключ => вычисление хэшкода => вычисление индекса ячейки => проверка свободна ли ячейка=> свободна - запись
                                                                                           => не свободна, хэшкод такой же, equals=false  => запись в конец (маленького LinkedLista) + создание ссылки (связи) из заполненной ячейки
                                                                                           => не свободна, хэшкод такой же, equals=true  => перезапись ячейки

     !!! Если при вычислении индекса у нескольких объектов он одинаковый, то они
     записываются по порядку в одну ячейку и имеют связи между собой
     */

    public static void main(String[] args) {
        //Создание HashMap (номер паспорта - ключ, ФИ - значение):
        Map<Integer,String> map1 = new HashMap<>();

        /**             Методы:                   */
        //1. Добавление элементов (put):
        System.out.println("1. Добавление элементов (put):");
        map1.put(1000, "Ksenia S");
        map1.put(5463, "Tatiana L");
        map1.put(3462, "Aleksey B");
        map1.put(5890, "Maria L");
        map1.put(2145, "Artem P");
        System.out.println("map1: " + map1);

        //2. Добавление элемента, если его нет (putIfAbsent):
        System.out.println("2. Добавление элемента, если его нет (putIfAbsent):");
        map1.putIfAbsent(3453,"Diana D");
        System.out.println("map1 с добавленным элементом: " + map1);

        //3. Вывести значение по  (get(ключ)):
        System.out.println("3. Вывести значение по  (get(ключ)):");
        System.out.println(map1.get(5890));

        //4. Удалить значение remove(ключ):
        System.out.println("4. Удалить значение remove(ключ):");
        map1.remove(1000);
        System.out.println("map1 без элемента Ксения с ключом 1000: " + map1);

        //5. Содержит ли HashMap определенное значение (.containsValue()) или ключ (.containsKey()) :
        System.out.println("5. Содержит ли HashMap определенное значение (.containsValue()) или ключ (.containsKey()):");
        System.out.println("Содержит ли map1 значение Diana D: " + map1.containsValue("Diana D"));

        //6. Вывести все ключи или значения, которые содержит HashMap (keySet()):
        System.out.println("6. Вывести все ключи или значения, которые содержит HashMap (keySet() или values()):");
        System.out.println(map1.keySet());
        System.out.println(map1.values());

        //7. Вывести все ключи или значения, разделенные точкой с запятой (entrySet):
        System.out.println("7. Вывести все ключи или значения, разделенные точкой с запятой (entrySet):");
        for(Map.Entry<Integer,String> entry: map1.entrySet()){
            System.out.println(entry.getKey() + " : " + entry.getValue());
        }


    }
}
