package collection.map.HashMap;

import java.util.HashMap;
import java.util.Map;

public class Hash_Map2 {
    /**
     Для увеличения производительности, можно:
     1) задать начальный размер массива- Initial capacity
     2) Load factor - коэффициент заполненности массива, после достижения которого массив будет увеличен в 2 раза
        (тип данных float, не забудь про букву ф на конце)

     напр., если loadFactor = 0,75, a Initial capacity = 16,
     то если хэшмэп будет содержать 12 элементов, то колличество ячеек увеличится в 2 раза (станет 32),
     и все элементы будут рехэшированы (и => перераспределены)

     !!!
     + чем больше Initial capacity, тем больше памяти займет и будет быстрее все работать
     (будет меньше линкед листов внутри ячеек)
     + чем больше Load factor, тем меньше памяти надо, но работать будет медленнее, из-за большого кол-ва линдекдЛистов


     Какова скорость метода get() определенного элемента?

     ответ О(1) - константное, очень быстрое (ограничено в основном временем поиска элемента в ячейке(в линдекЛисте)
     так как время поиска ячейки в котором содержится элемент = О(1) - константное, а потом О(n)-время поиска элемента в LinkedListe
     т.е чем ближе он в LinkedListe, тем меньше время поиска

     О(n) - если очень плохо реализовать метод hashcode,
     если метод хэшкод будет выдавать часто коллизи (элементы с одинаковым хэшкодом) и индекс ячейки тогда будет один,
     то все элементы попадут в одну ячейку и будем искать по -сути по одному LinkedListу, а значит время будет О(n)

     C 8ой джавы, если LinkedList очень длинный, то джава перестает хранить код там и начинает
     хранить в сбалансированных деревьях
     */
    public static void main(String[] args) {
        //Дефолтные значения HashMap:
        Map<Integer,String> map2 = new HashMap<>(16,0.75f);

    }

}
